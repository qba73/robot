package robotname

import (
	"regexp"
	"sync"
	"testing"
)

var namePat = regexp.MustCompile(`^[A-Z]{2}\d{3}$`)

//var seen = map[string]int{}

type cache struct {
	mu    sync.Mutex
	items map[string]bool
}

func (m *cache) get(name string) (string, bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if _, ok := m.items[name]; !ok {
		return "", false
	}
	return name, true
}

func (m *cache) add(name string) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.items[name] = true
}

func (m *cache) len() int {
	m.mu.Lock()
	defer m.mu.Unlock()
	return len(m.items)
}

var seen = &cache{items: map[string]bool{}}

func New() *Robot { return new(Robot) }

// getName is a test helper function to facilitate optionally checking for seen
// robot names.
func (r *Robot) getName(t testing.TB, expectSeen bool) string {
	t.Helper()
	newName, err := r.Name()
	if err != nil {
		t.Fatalf("Name() returned unexpected error: %v", err)
	}
	if len(newName) != 5 {
		t.Fatalf("names should have 5 characters: name '%s' has %d character(s)", newName, len(newName))
	}

	//_, chk := seen[newName]
	_, chk := seen.get(newName)
	if !expectSeen && chk {
		//t.Fatalf("Name %s reissued after %d robots.", newName, len(seen)
		t.Fatalf("Name %s reissued after %d robots.", newName, seen.len())

	}
	seen.add(newName)
	//seen[newName] = 0
	return newName
}

func TestNameValid(t *testing.T) {
	t.Parallel()

	n := New().getName(t, false)
	if !namePat.MatchString(n) {
		t.Errorf(`Invalid robot name %q, want form "AA###".`, n)
	}
}

func TestNameSticks(t *testing.T) {
	t.Parallel()

	r := New()
	n1 := r.getName(t, false)
	n2 := r.getName(t, true)
	if n2 != n1 {
		t.Errorf(`Robot name changed.  Now %s, was %s.`, n2, n1)
	}
}

func TestSuccessiveRobotsHaveDifferentNames(t *testing.T) {
	t.Parallel()

	n1 := New().getName(t, false)
	n2 := New().getName(t, false)
	if n1 == n2 {
		t.Errorf(`Robots with same name.  Two %s's.`, n1)
	}
}

func TestResetName(t *testing.T) {
	t.Parallel()

	r := New()
	n1 := r.getName(t, false)
	r.Reset()
	if r.getName(t, false) == n1 {
		t.Errorf(`Robot name not cleared on reset.  Still %s.`, n1)
	}
}

// Test 1000 names are unique - this should run reasonably quickly even with a solution that is not particularly fast.
func TestMultipleNames(t *testing.T) {
	t.Parallel()

	// Test uniqueness for new robots.
	// for i := len(seen); i <= 1000; i++ {
	// 	New().getName(t, false)
	// }
	for i := seen.len(); i <= 1000; i++ {
		New().getName(t, false)
	}
}

var maxNames = 26 * 26 * 10 * 10 * 10

const lotsOfNames = 76000

// TestCollisions tests if unique names are generated by creating new robots until all names are used.
func TestCollisions(t *testing.T) {
	t.Parallel()
	// Remove the next line to make this test run
	//t.Skip("skipping test as solutions that are not particularly fast can exceed testing time limits.")

	// Test uniqueness for new robots.
	for i := seen.len(); i <= lotsOfNames; i++ {
		New().getName(t, false)
	}

	// Test that names aren't recycled either.
	// Note that this runs till names are exhausted.
	r := New()
	for i := seen.len(); i < maxNames; i++ {
		r.Reset()
		r.getName(t, false)
	}

	// Test that name exhaustion is handled more or less correctly.
	_, err := New().Name()
	if err == nil {
		t.Fatalf("should return error if namespace is exhausted")
	}
}
